<!DOCTYPE html>
<html>

<!-- test comment -->

<head>
	<meta charset="UTF-8">
	<title>cockatiel | by vulbyte</title>
	<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
</head>

<body>
	<style>
		* {
			background-color: black;
			color: white;
			font-family: Helvetica, Arial, sans-serif;
		}

		impl {
			background-color: yellow;
			color: darkred;
			display: block;
			width: 10em;
			;
		}
	</style>
	<button id='save_button'>save values</button>
	<button id='load_button'>load values</button>
	<script>
		document.getElementById('save_button').addEventListener('click', (e) => {SaveValues()})
		document.getElementById('load_button').addEventListener('click', (e) => {LoadValues()})
		function SaveValues() {
			let inputs = document.getElementsByTagName('input');

			let save_map = {};
			for (let i = 0; i < Object.keys(inputs).length; ++i) {
				save_map[inputs[i].id] = inputs[i].value;
			}
			console.log(save_map);
			localStorage.setItem('inputs', JSON.stringify(save_map));
		}

		function LoadValues() {
			let values = localStorage.getItem('inputs');
			values = JSON.parse(values);
			console.log(values);
			let inputs = document.getElementsByTagName('input');

			for (let i = 0; i < inputs.length; ++i) {
				try {
					let ce = inputs[i];
					if (values[ce.id] == null) {console.log(`null value with ${ce.id}`); continue;}
					if (values[ce.id] == undefined) {console.log('undefined'); continue;}
					if (values[ce.id] == null) {console.log("''"); continue;}

					ce.value = values[ce.id];
				}
				catch (err) {
					console.warn(err);
				}
			}
		}
	</script>
	<h1>cockatiel</h1>
	<details>
		<summary>youtube stuff</summary>

		<input id="youtube_api_key" placeholder="youtube_api_key" type="password"></input>
		<input id="channel_name" placeholder="channel_name" type="text"></input>
		<button id="get_channel_id_button">get_channel_id_button</button>
		<br>
		<em>don't fill this out unless you already know it, the wizard can do this for you!</em>
		<input placeholder="channel_id" id="channel_id" type='text'></input>
		<script type="module">
			function ApiKey() {
				let ak = document.getElementById("youtube_api_key").value;
				return (ak);
			};

			const ChannelName = ((e) => {
				return (document.getElementById("channel_name"));
			})

			document.getElementById('get_channel_id_button').addEventListener('click', () => {
				GetChannelId();
			})


			async function GetChannelId() {
				try {
					document.getElementById('popup').remove();
				}
				catch (err) {
					console.warn(err)
				}

				const YtChannelIdQuery = new Promise(async (resolve, reject) => {
					try {
						setTimeout(() => {(reject(`couldn't load response in time`))}, 5000);
						const base_url = "https://www.googleapis.com/youtube/v3/";
						const params = String(
							'search' +
							'?part=snippet' +
							'&key=' + String(ApiKey()) +
							'&q=vulbyte' +
							'&type=channel' +
							'&maxResults=3' +
							''
						);

						let fetch_url = String(base_url + params);

						let response = await fetch(fetch_url);
						if (!response.ok) {
							reject('data is not correct' + data);
						}
						let data = response.json();
						console.log(data);

						resolve(data);
					}
					catch (err) {
						console.log(err);
					}
				});

				let response = await YtChannelIdQuery;

				console.log(response);

				function CE(args = {
					'elem': undefined,
					'it': undefined,
					'id': undefined,
					'href': undefined,
					'alt': undefined,
					'src': undefined,
				}) {
					//does not do styling!
					console.log(args);
					let ce;

					if (args.elem == '' || args.elem == undefined || args.elem == null) {
						ce = document.createElement('div');
					}
					else {
						ce = document.createElement(args.elem);
					}

					if (args.alt != '' || args.alt != undefined || args.alt != null) {
						ce.alt = args.alt;
					}

					if (args.href != '' || args.href != undefined || args.href != null) {
						ce.href = args.href;
					}
					if (args.id != '' || args.id != undefined || args.id != null) {
						ce.id = args.id;
					}
					if (args.it != '' || args.it != undefined || args.it != null) {
						ce.innerText = args.it;
					}
					if (args.src != '' || args.src != undefined || args.src != null) {
						ce.src = args.src;
					}

					return (ce);
				}

				if (response.items.length == 1) {
					console.log("only one item");

					let popup = CE({'id': 'popup'});
					popup.style.backgroundColor = 'blue';
					popup.style.color = 'black';
					popup.style.height = 'auto';
					popup.style.position = 'absolute';
					popup.style.width = '30em';

					document.body.appendChild(popup);
					popup = document.getElementById('popup');
					await setTimeout(() => { }, 100);

					function LeftOffset() {
						let win, pu;
						win = window.innerWidth;
						try {
							pu = document.getElementById('popup').getBoundingClientRect().x;
						}
						catch (err) {console.warn(err)}
						let offset = ((win - pu) / 2);
						console.log(
							`y offset: ${offset}`,
							`win: ${win}`,
							`pu: ${pu}`,
						);
						return offset / 2;
					}

					function TopOffset() {
						let win, pu;
						win = window.innerHeight;
						try {
							pu = document.getElementById('popup').getBoundingClientRect().y;
						}
						catch (err) {console.warn(err)}
						let offset = ((win - pu) / 2);
						console.log(
							`y offset: ${offset}`,
							`win: ${win}`,
							`pu: ${pu}`,
						);
						if (offset <= 0) {return (0)}
						return offset / 2;
					}

					console.log(
						'centering popup',
						LeftOffset(), ", ", TopOffset(), "\n",
						popup.getBoundingClientRect().x, ", ", popup.getBoundingClientRect().y
					);
					document.getElementById('popup').style.left =
						LeftOffset() + "px";
					document.getElementById('popup').style.top = TopOffset() + "px";

					popup.appendChild(CE({
						'it': 'only one result found, is this right?'
					}));

					let single_channel = CE();
					//img
					single_channel.appendChild(CE({
						'elem': 'img',
						'src': response.items[0].snippet.thumbnails.medium.url,
						'alt': `image of the channel ${response.items[0].snippet.ChannelName}`
					}));
					//channel name
					single_channel.appendChild(CE({
						'elem': 'h2',
						'it': response.items[0].snippet.title
					}));

					let confirm = CE({
						'elem': 'button',
						'id': 'confirm_channel_btn',
						'it': '✅',
					});
					confirm.addEventListener('click', (e) => {
						document.getElementById('channel_id').value = response.items[0].snippet.channelId;
						popup.remove();
					});
					single_channel.appendChild(confirm);

					let deny = CE({
						'elem': 'button',
						'id': 'deny_channel_btn',
						'it': '❌'
					});
					deny.addEventListener('click', (e) => {
						console.log('removing popup');
						//document.getElementById('channel_id').value = resposne.items[0].snippet.channelId;
						popup.remove();
					});
					single_channel.appendChild(deny);

					popup.appendChild(single_channel)
				}
				else {
					console.log("more than one item returned");

					let popup = CE({'id': 'popup'});
					popup.style.backgroundColor = 'blue';
					popup.style.color = 'black';
					popup.style.height = 'auto';
					popup.style.position = 'absolute';
					popup.style.width = '30em';

					await document.body.appendChild(popup);
					popup = document.getElementById('popup');

					let left = window.innerWidth;
					let top = window.innerHeight;

					popup.style.left =
						(window.innerWidth - popup.getBoundingClientRect().x) / 2;
					popup.style.bottom =
						(window.innerHeight - popup.getBoundingClientRect().y) / 2;

					popup.appendChild(CE({
						'it': 'multiple results! which is right?'
					}));

					let channel_list = CE({'elem': 'ul'});

					for (let i = 0; i < response.items.length; ++i) {
						let channel_item = response.items[i];

						//img
						channel_item.appendChild(CE({
							'elem': 'img',
							"it": response.items[0].snippet.thumbnails.medium.url
						}));
						//channel name
						channel_item.appendChild(CE({
							'elem': 'h2',
							'it': response.items[0].snippet.title
						}));

						let confirm = CE({
							'elem': 'button',
							'id': 'confirm_channel_btn',
							'it': '✅',
						});
						confirm.addEventListener('click', (e) => {
							document.getElementById('channel_id').value = response.items[0].snippet.channelId;
							popup.remove();
						});
						channel_item.appendChild(confirm);

						let deny = CE({
							'elem': 'button',
							'id': 'deny_channel_btn',
							'it': '❌'
						});
						document.getElementById(deny.id).addEventListener('click', (e) => {
							console.log('removing popup');
							popup.remove();
						});
						channel_item.appendChild(deny);
					}//end of for loop

					popup.appendChild(channel_list);
				}
			}

		</script>

		<button id="select_yt_livestream_btn" style="background-color:#ff0000;">
			select a currently live youtube stream
		</button>
		<button id="select_upcoming_yt_livestream_btn" style="background-color:yellow; color: black;">
			select scheduled youtube stream
		</button>
		<script>
			function CE(args = {
				'elem': undefined,
				'it': undefined,
				'id': undefined,
				'href': undefined,
				'alt': undefined,
				'src': undefined,
			}) {
				//does not do styling!
				//console.log(args);
				let ce;

				if (args.elem == '' || args.elem == undefined || args.elem == null) {
					ce = document.createElement('div');
				}
				else {
					ce = document.createElement(args.elem);
				}

				if (args.alt != '' || args.alt != undefined || args.alt != null) {
					ce.alt = args.alt;
				}

				if (args.href != '' || args.href != undefined || args.href != null) {
					ce.href = args.href;
				}
				if (args.id != '' || args.id != undefined || args.id != null) {
					ce.id = args.id;
				}
				if (args.it != '' || args.it != undefined || args.it != null) {
					ce.innerText = args.it;
				}
				if (args.src != '' || args.src != undefined || args.src != null) {
					ce.src = args.src;
				}

				return (ce);
			}

			let d = document;
			function GEBI(id) {return (d.getElementById(id))};

			GEBI("select_yt_livestream_btn").addEventListener('click', (e) => {
				let ak = GEBI("youtube_api_key").value;
				if (ak == null || ak == undefined || ak == '') {
					console.warn('missing api key!');
					return;
				}
				let ci = GEBI("channel_id").value;
				if (ci == null || ci == undefined || ci == '') {
					console.warn('missing channel id!');
					return;
				}

				GetYoutubeLiveStreamsFromChannel();
			});

			function GetYoutubeLiveStreamsFromChannel() {
				let ak = GEBI("youtube_api_key").value;
				let id = GEBI("channel_id").value;


				fetch(`
					https://www.googleapis.com/youtube/v3/search
							?part=snippet
							&channelId=${id}
							&eventType=live
							&type=video
							&key=${ak}
				`)
					.then(response => response.json())
					.then(data => console.log(data))
					.catch(err => console.warn(err))
			}

			GEBI("select_upcoming_yt_livestream_btn").addEventListener('click', (e) => {
				let ak = GEBI("youtube_api_key").value;
				if (ak == null || ak == undefined || ak == '') {
					console.warn('missing api key!');
					return;
				}
				let ci = GEBI("channel_id").value;
				if (ci == null || ci == undefined || ci == '') {
					console.warn('missing channel id!');
					return;
				}

				GetUpcomingYoutubeLiveStreamsFromChannel();
			});
			function GetUpcomingYoutubeLiveStreamsFromChannel() {
				console.log('getting upcomings streams');
				let ak = GEBI("youtube_api_key").value;
				let id = GEBI("channel_id").value;

				fetch(`
					https://www.googleapis.com/youtube/v3/search
							?part=snippet
							&channelId=${id}
							&eventType=upcoming
							&type=video
							&key=${ak}
				`)
					.then(response => response.json())
					.then((data) => {
						console.log(data)
						let container = CE({"elem": "ul", "id": "stream_selection"});
						container.style.paddingBottom = "3rem";
						for (let i = 0; i < data.items.length; ++i) {
							let item = data.items[i];
							console.log(`making item for loop ${i} item: ${item}`);

							let stream_item = CE({"elem": "li", "id": "stream_item"});

							let thumbnail = CE({
								"elem": "img",
								"src": `${item.snippet.thumbnails.medium.url}`,
								"alt": `thumbnail of stream: ${item.snippet.title}`
							});
							stream_item.appendChild(thumbnail);

							let title = CE({"elem": "h3", "it": item.snippet.title});
							stream_item.appendChild(title);

							let select = CE({"elem": "button", "it": "click here to select this stream"});
							select.addEventListener("click", (e) => {
								document.getElementById("youtube_stream_id").value = (item.id.videoId);
								container.remove();
							});
							stream_item.appendChild(select);

							container.appendChild(stream_item);
						}
						document.body.appendChild(container);
					})
					.catch(err => console.warn(err))
			}
		</script>
		<br>
		<input id="youtube_stream_id" placeholder="stream_id"></input>
		<button id="get_youtube_livestream_chat_id">get youtube livestream chat id</button>
		<script>
			document.getElementById('get_youtube_livestream_chat_id').addEventListener('click', () => {
				GetYoutubeLivestreamChatIdFromVideoId();
			})
			function GetYoutubeLivestreamChatIdFromVideoId() {
				fetch(
					`https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${document.getElementById('youtube_stream_id').value}&key=${document.getElementById('youtube_api_key').value}`
				)
					.then(response => response.json())
					.then((data) => {
						console.log(data);
						let chat_id = data.items[0].liveStreamingDetails.activeLiveChatId;
						document.getElementById('youtube_chat_id').value = chat_id;
					})
					.catch((err) => {console.warn(err)});
			}
		</script>
		<br>
		<input id='youtube_chat_id' placeholder="youtube_chat_id"></input>
	</details>
	<br>
	<br>

	<button id='start_monitoring_messages' style='background-color:green;'>start monitoring</button>
	<button id='stop_monitoring_messages' style='background-color:red;'>stop monitoring</button>
	<script>
		class IntTimer {
			constructor(
				args = {
					timerName: "",
					tick: 1,
					timeoutDuration: 5,
					killOnTimeout: true,
					autoStart: false
				}
			) {
				this.timerName = args.timerName;
				this.tick = args.tick;
				this.timeoutDuration = args.timeoutDuration;
				this.killOnTimeout = args.killOnTimeout;
				this.time = 0;
				this.autoStart = args.autoStart;

				this.listeners = [];

				if (this.autoStart == true) {
					this.Start();
				}
			}

			Start() {
				console.log(`IntTimer: Starting timer with interval of: ${this.timeoutDuration}`);
				this.timer = setInterval(() => {
					this.Tick();

				}, 1000);
			}

			Pause() {
				clearInterval(this.timer);
			}

			Stop() {
				this.Pause();
				this.Restart();
			}

			Restart() {
				this.time = 0;
			}

			Tick() {
				console.log(`timer ${this.timerName}: tick`);

				this.time += 1;

				if (this.time % this.timeoutDuration == 0) {
					this.Timeout();
				}
			}

			Timeout() {
				console.log(`timer ${this.timerName} Has Timeout'd`);

				this.Emit();

				if (this.killOnTimeout == true) {
					this.Kill();
				}
			}

			Kill() {
				console.log(`timer ${this.timerName} Has been killed`);
				this.killOnTimeout = true;

				this.listeners = [];

				clearInterval(this.timer);
			}

			// signal stuff
			Connect(connect_func) {
				this.listeners.push(connect_func);
			}

			Emit(data) {
				console.log('listener amnt: ' + this.listeners.length);
				//console.log('listeners: ' + this.listeners.json());

				for (let i = 0; i < this.listeners.length; ++i) {
					this.listeners[i](data);
					//if (typeof this.listeners[i] === 'function') {
					//} else {
					//	console.error("Listener is not a function:", this.listeners[i]);
					//}
				}
			}

			Disconnect(listener) {
				this.listeners = this.listeners.filter(l => l !== listener);
			}
		}

		let Timer;
		Timer = new IntTimer({'killOnTimeout': false});


		document.getElementById('start_monitoring_messages').addEventListener('click', (e) => {
			console.log('Timer started');
			Timer.timeoutDuration = 1;
			Timer.Connect(() => {
				GetAndUpdateMessages();
				Timer.timeoutDuration = document.getElementById('youtube_chat_update_interval').value;
				d.getElementById('tts_message_total').innerText = d.getElementById("messages_display").children.length - 1;

				let count = Timer.timeoutDuration;
				let timer = setInterval(() => {
					count -= 1;
					d.getElementById('tts_update_time').innerText = count;
					if (count == 0) {clearInterval(timer)};
				}, 1000);
			});
			Timer.Start();
		});
		document.getElementById('stop_monitoring_messages').addEventListener('click', (e) => {
			console.log('Timer killed');
			Timer.Stop();
		});

		function GetYtTimeoutDuration() {
			return (document.getElementById('youtube_chat_update_interval').value);
		}

		let old_messages;

		async function GetYtMessages() {
			let messages;
			let id = document.getElementById('youtube_chat_id').value;
			let ak = document.getElementById('youtube_api_key').value;

			try {
				const response = await fetch(`https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${id}&part=snippet,authorDetails&key=${ak}`);
				const data = await response.json();
				//console.log("DATA FROM FETCH: ", data);
				return data;
			}
			catch (err) {
				console.error(err);
			}
		}

		async function GetAndUpdateMessages() {
			const Prom = new Promise((resolve, reject) => {
				console.log(`timeout duration is: ${ytci.value * 1000}ms`)
				setTimeout((e) => {
					reject(
						'could not get and list messages before next interval!'
					)
				}, (ytci.value) * 1000);

				let table = document.getElementById('messages_display');
				console.log('getting messages');

				try {
					GetYtMessages().then((messages) => {
						//console.log("%j", messages);
						try {
							console.log(
								'messages.length' + messages.items.length
							);
						}
						catch (err) {
							console.warn('message.length could not be read:', err);
						}

						let break_outer_loop = false;
						old_messages = d.getElementById("messages_display").children;
						//go from newest to oldest
						for (let i = messages.items.length - 1; i >= 0; --i) {
							let message = messages.items[i];
							break_outer_loop = false

							//check if already in list
							for (let j = old_messages.length - 1; j > 0; --j) {
								if (
									// BUG: this is erroring when reading 1 at some point
									old_messages[j].children[0].innerText == message.authorDetails.displayName &&
									old_messages[j].children[2].innerText == message.snippet.publishedAt &&
									old_messages[j].children[3].innerText == message.snippet.displayMessage
								) {
									break_outer_loop = true;
									console.log('duplicate message found, adding new messages and moving on!');
									break;
								}
							}

							if (break_outer_loop) {
								break;
							}

							//{{{3 create element
							let row = CE({
								'elem': 'tr',
								'id': `row${i}`
							});
							row.innerText = '';

							let tr_author = CE({
								'elem': 'td',
								'id': 'td_author',
							});
							tr_author.innerText = message.authorDetails.displayName;
							row.appendChild(tr_author);

							let tr_platform = CE({
								'elem': 'td',
								'id': 'td_platform',
							});
							tr_platform.innerText = 'youtube';
							row.appendChild(tr_platform);

							let tr_date = CE({
								'elem': 'td',
								'id': 'td_date',
							});
							tr_date.innerText = message.snippet.publishedAt;
							row.appendChild(tr_date);

							let tr_message = CE({
								'elem': 'td',
								'id': 'td_message',
							});
							tr_message.innerText = message.snippet.displayMessage;
							row.appendChild(tr_message);

							let tr_play_now = CE({
								'elem': 'td',
								'id': 'td_play_now',
								'it': '',
							});
							let tr_play_now_button = document.createElement('button');
							tr_play_now_button.id = 'tr_play_now_button';
							tr_play_now_button.innerText = '▶️';
							tr_play_now_button.checked = true;
							function tr_play_tts() {
								// {{{6 GPT THING, TODO: REWRITE, ADD -l
								function parseTTSCommand(message) {
									console.log('Parsing TTS commands on message: ' + message);

									// Ensure message starts with "!tts"
									let start_token = String(
										document.getElementById('tts_trigger_token').value ||
										document.getElementById('tts_trigger_token').placeholder
									);

									console.log("Start Token:", start_token, "Message:", message);

									if (!message.startsWith(start_token)) {
										return ""; // Not a TTS command
									}

									// Split command and message at ";;"
									const parts = message.split(";;");
									const commandPart = parts[0].split(" "); // Extract arguments
									const messageText = parts[1] ? parts[1].trim() : ""; // Extract text after ";;"

									let tts_args = {
										"rate": document.getElementById('tts_speed').value,
										"pitch": document.getElementById('tts_pitch').value,
										"voiceIndex": document.getElementById('tts_voice_num').value,
									};

									// Parse command arguments
									for (let i = 1; i < commandPart.length; i++) {
										if (commandPart[i] === "-p" && commandPart[i + 1]) {
											tts_args.pitch = commandPart[i + 1];
										} else if (commandPart[i] === "-r" && commandPart[i + 1]) {
											tts_args.rate = commandPart[i + 1];
										} else if (commandPart[i] === "-v" && commandPart[i + 1]) {
											tts_args.voiceIndex = commandPart[i + 1];
										}
									}

									// Apply settings if changed
									document.getElementById('tts_pitch').value = tts_args.pitch;
									document.getElementById('tts_speed').value = tts_args.rate;

									console.log('Parsed TTS values:', tts_args);

									return tts_args;
								}

								const tts_args = parseTTSCommand(message.snippet.displayMessage);
								//}}} 6
								//{{{3 CallTSS() and bind
								async function CallTTS(
									message,
									args = tts_args || {
										'voiceIndex': document.getElementById('tts_voice_num'),
										'pitch': document.getElementById('tts_pitch'),
										'rate': document.getElementById('tts_speed')
									}
								) {
									console.log('CallTTS args: ' + JSON.stringify(args));
									let speech = new SpeechSynthesisUtterance(message);

									// Ensure voices are loaded
									let voices = window.speechSynthesis.getVoices();
									if (!voices.length) {
										await new Promise(resolve => {
											window.speechSynthesis.onvoiceschanged = () => {
												voices = window.speechSynthesis.getVoices();
												resolve();
											};
										});
									}

									// Default message if empty
									if (!message || message.trim() == "") {
										message = "nah, i ain't reading that... I'm sorry or congratulations";
									}
									// trim the commands
									let delimiter =
										document.getElementById('tts_delimiting_token').value ||
										document.getElementById('tts_delimiting_token').value
									let delimiter_location = message.indexOf(delimiter);
									console.log('DELIMITER: ' + delimiter + '\n' + 'DELIMITER LOCATION: ' + delimiter_location);
									if (delimiter_location != -1) {
										let new_message = message.slice(delimiter_location + delimiter.length, message.length);
										console.log('new_message: ' + new_message);
										speech.text = new_message;
									}
									else {
										speech.text = message;
									}

									try {
										console.log("call_tts, reading config: ", args);
										speech.lang = "en_US";
										speech.voice = voices[args.voiceIndex];
										speech.volume = 0.6;
										speech.rate = args.rate || document.getElementById('tts_speed').value;
										speech.pitch = args.pitch || document.getElementById('tts_pitch').value;
									}
									catch (err) {
										console.warn("Error loading settings: ", err);
										// Fallback values
										speech.lang = "en";
										speech.pitch = document.getElementById('tts_pitch').value;
										speech.rate = document.getElementById('tts_speed').value;
										speech.voice = voices[document.getElementById('tts_voice_num').value] || voices[0]; // Ensure voices exist
										speech.volume = 0.6;
									}

									// Emit voice
									window.speechSynthesis.speak(speech);
								}
								async function emit_voice(speech) {
									await window.speechSynthesis.speak(speech);
								}

								CallTTS(document.getElementById(`row${i}`).children[3].innerText);
								//}}}3
							}
							tr_play_now_button.addEventListener('click', (e) => {
								tr_play_tts();
							});

							let tr_in_queue = CE({
								'elem': 'td',
								'id': 'td_in_queue_container',
							});
							tr_in_queue.innerText = '';
							tr_in_queue_toggle = CE({
								'elem': 'input',
								'id': 'is_tss_message_in_queue'
							});
							tr_in_queue_toggle.type = 'checkbox';
							async function AddMessageToQueue() {
								tr_play_now.appendChild(tr_play_now_button);
								row.appendChild(tr_play_now);

								let ttstt = GEBI('tts_trigger_token');
								ttstt = ttstt.value | ttstt.placeholder;
								let message_text = message.snippet.displayMessage;
								// TODO: this for filtering
								/*function EvalIfShouldAddMessageToQueue() { // returns 0 if checks are valid, other if false
									if (message_text.includes(ttstt)) {
										let should_be_added_to_queue = true;
										//delimiter check
										let delimiter = GEBI('tts_delimiting_token');
										if (GEBI('tts_strict_delimiters').checked == true) {
											if (message_test.includes(delimiter) == false) {
												return 1;
											}
										}
										//strict flags
										if (GEBI('tts_strict_flags') == true) {
											let flags = ['-p', '-r', '-v', '-l'];
											let window =
												message_test = message_text.slice(
													message_text.indexOf('ttstt') + ttstt.length,
													message_text.indexOf(delimiter)
												);

											let invalid_token_found = true;
											for (let i = 0; i < message_test.length; ++i) {
												if (char == '-') {
													for (let j = 0; j < flags.length; ++j) {
														if (
															message_test.slice(j, flags[j].length) ==
															flags[i]
														) {

														}
													}
													if (invalid_token_found == true) {
														console.warn('message did not conform to strict flags setting');
														return (2);
													}
												}
											};
										}
										// TODO: token location
									}
								};
								tr_in_queue_toggle.checked = EvalIfShouldAddMessageToQueue();*/
								tr_in_queue_toggle.checked = (
									message.snippet.displayMessage.includes(
										document.getElementById("tts_trigger_token").value
									) &&
									message.snippet.displayMessage.includes(
										document.getElementById("tts_delimiting_token").value
									)
								);
								tr_in_queue.appendChild(tr_in_queue_toggle);
								row.appendChild(tr_in_queue);

								let tr_skip = CE({
									'elem': 'td',
									'id': 'td_skip',
								});
								row.appendChild(tr_skip);

								let tr_delete = CE({
									'elem': 'td',
									'id': 'td_delete',
								});
								tr_delete.innerText = '❌';
								tr_delete.addEventListener('click', (e) => {
									row.remove();
								});
								row.appendChild(tr_delete);

								console.log('adding message');
								table.appendChild(row);
								//}}}
							}// end of loop
							AddMessageToQueue();
						}
					});
				}
				catch (err) {
					console.log(`couldn't get messages`);
					return;
				}
				console.log('added all messages');

				resolve();
			});
		};
	</script>
	<input id='youtube_chat_update_interval' style=' color:#000;' type='range' min='5' max='120' value='20'>
	<span>
		interval:
		<span id='youtube_chat_update_interval_display'></span>
		seconds
	</span>
	<br>
	<details>
		<summary>warning about adjusting the interval!</summary>
		<sub>
			please note! i recommend tuning this to 'as needed'.
			<br>
			according to <a href='https://developers.google.com/youtube/v3/determine_quota_cost'
				target='_blank'>youtube/google's api docs, the average cost</a> and testing, the average cost per message is
			approximately 50-100 tokens. with a default limit of 10,000; to be able to stream 24/7 means you should set your
			update interval to about every 10 seconds. if you stream for a shorter period i made you a helpful little table
			you
			can view:
		</sub>
		<details>
			<summary>here</summary>
			<table>
				<tbody>
					<tr>
						<th>max-hours</th>
						<th>update interval</th>
					</tr>
					<tr>
						<td>24 hours</td>
						<td>10 seconds (default)</td>
					</tr>
					<tr>
						<td>16 hours</td>
						<td>8 seconds</td>
					</tr>
					<tr>
						<td>12 hours</td>
						<td>7 seconds</td>
					</tr>
					<tr>
						<td>10 hours </td>
						<td>7 seconds</td>
					</tr>
					<tr>
						<td>9 hours</td>
						<td>7 seconds</td>
					</tr>
					<tr>
						<td>8 hours</td>
						<td>6 seconds</td>
					</tr>
					<tr>
						<td>7 hours</td>
						<td>6 seconds</td>
					</tr>
					<tr>
						<td>6 hours</td>
						<td>6 seconds</td>
					</tr>
					<tr>
						<td>5 hours</td>
						<td>6 seconds</td>
					</tr>
					<tr>
						<td>4 hours</td>
						<td>5 seconds</td>
					</tr>
					<tr>
						<td>3 hours</td>
						<td>5 seconds</td>
					</tr>
					<tr>
						<td>2 hours</td>
						<td>5 seconds</td>
					</tr>
					<tr>
						<td>1 hours</td>
						<td>5 seconds</td>
					</tr>
				</tbody>
			</table>
		</details>
	</details>
	<script>
		ytci = document.getElementById('youtube_chat_update_interval');
		ytcid = document.getElementById('youtube_chat_update_interval_display');

		ytcid.innerText = 20;

		ytci.addEventListener('mousemove', (e) => {
			ytcid.innerText = ytci.value;
		})
	</script>


	<style>
		table {
			border: 1px solid #ffffff;
			max-height: 20em;
			margin-bottom: 6em;
			max-width: 95%;
			overflow-y: scroll !important;
		}

		tbody {
			height: 20em;
			overflow-y: scroll !important;
		}


		#messages_display>tr>th:nth-child(2n+1) {
			background-color: #333;
		}

		#messages_display>tr>td {
			border: 1px solid #ffffff;
			border-radius: 5px;
			padding: 0.5em;
			margin: auto;
			text-align: center;
		}

		#messages_display>tr>td:nth-child(2n+1) {
			background-color: #333;
		}

		#messages_display>tr>td:nth-child(5) {
			background-color: lightgreen;
		}

		#messages_display>tr>td:nth-child(6) {
			background-color: lightyellow;
		}

		#messages_display>tr>td:nth-child(7) {
			background-color: moccasin;
		}

		#messages_display>tr>td:nth-child(8) {
			background-color: lightcoral;
		}
	</style>
	<div>
		<details>
			<summary>tts setting here</summary>
			<details>
				<summary>view all the tags here</summary>
				<sub>
					note: the values if a range use integral notation.
					the tldr is: <br>
					[ or ] means to that value including it,<br>
					( or ) means to that value excluding it,<br>
					a number without a decimal means that number must be an integer<br>
					while a number with a decimal means that number can be a float (have a decimal)<br>
					and the numbers between are the range.<br><br>
					eg: (0, 1000] means the range is 0-1000, including 1000 but excluding 0.
					eg: [0.1, 7.0] means the range 0.1-7.0 is valid and anything between.

				</sub>
				<table>
					<tbody>
						<tr>
							<th>flag</th>
							<th>values</th>
							<th>description</th>
						</tr>
						<tr>
							<td>-p</td>
							<td>[0.1, 2.0]</td>
							<td>the <em>p</em>itch a message will be read with</td>
						</tr>
						<tr>
							<td>-r</td>
							<td>[0.1, 10.0]</td>
							<td>the <em>r</em>ate at which a message is read</td>
						</tr>
						<tr>
							<td>-v</td>
							<td>[0, 175]</td>
							<td>the <em>v</em>oice a tts message will use</td>
						</tr>
						<tr>
							<td>-l</td>
							<td id='tts_languages'></td>
							<td>the language for the tts bot. largely isn't used and wont make a difference, though some bots might
								change behavior based on the setting</td>
						</tr>
					</tbody>
				</table>
			</details>
			<br>
			<label>tts trigger token: </label>
			<br>
			<sub>make this unique unless you want people to accidentally use it! i recommend !tts due to being similar to bots
				in discord</sub>
			<input id='tts_trigger_token' placeholder='!tts'>
			<br>
			<input id='tts_delimiting_token' placeholder=';;'>
			<sub>this will be the token used to tell what the end of the user commands for the bot. ie: <code>!tts -p 1.2
					;;</code> would make it so that the tts will be called with the pitch changed, and with the ;; found it can
				quickly move on wasting less system resources</sub>
			<sub>warning! it is very very very bad practice to make the delimiting character an 'invisable' character. as
				these are often formatted and impossible to read. so <em>do not</em> use things like spaces, new lines,
				etcetc.</sub>
			<br>
			<impl>impl ⬇️</impl>
			<label>strict adherence to limiter and delimiter?</label>
			<input id='tts_strict_delimiters' type='checkbox' default='false'>
			<sub>this will make it so that if a tts message cannot find a limiter and delimiter it will <em>not</em> run the
				tts for that message.
				command. ie if your limiter is: '!tts' and your delimiter is ';;', if the message cannot find the ';;' it will
				refuse to add the message to queue</sub>
			<br>
			<impl>impl ⬇️</impl>
			<label>strict flags?</label>
			<input id='tts_strict_flags' type='checkbox' default='false'>
			<sub>if a flag is not recognized, ignore the rest of the rest of the tts, even if the flags are valid</sub>
			<br>
			<impl>impl ⬇️</impl>
			<label>token location: </label>
			<!-- {{{2  options for token location-->
			<select id='tts_trigger_token' placeholder='beginning' default='beginning'>
				<option value='beginning'>
					beginning - requires the tts token to be at the very beginning of the message, then will read the whole
					message
				</option>
				<option value='anywhere-after'>
					anywhere_all - the tts token can be ANYWHERE in the message to trigger the tts, then will read what's
					after
					the token.
				</option>
				<option value='anywhere-before'>
					anywhere_before - the tts token can be ANYWHERE in the message to trigger the tts, then will read what's
					before the token.
				</option>
				<option value='anywhere-all'>
					anywhere_all - the tts token can be ANYWHERE in the message to trigger the tts, then will read the whole
					message.
				</option>
				<option value='end'>
					end - requires the tts token to be at the end of the message to be read, then will read the whole message.
				</option>
			</select>
			<!-- }}}2 -->
			<br>
			<label>default tts voice: </label>
			<input id='tts_voice_num' input='number' placeholder='18'>
			<!-- {{{2 preview generator for tts voices -->
			<label>tts speed: </label>
			<input id='tts_speed' input='number' increment='0.1' value='1' min='0.1' max='2'>
			<label>tts pitch: </label>
			<input id='tts_pitch' input='number' increment='0.1' value='1' min='0.1' max='2'>
			<!-- {{{2 preview generator for tts voices -->
			<details>
				<summary>preview all the voices here!</summary>
				<br>
				<div>test message:
					<input id='tts_test_text' value='the quick brown fox jumped over the brown lazy dog' style='width:80%;'>
				</div>
				<ol id='voices_preview'></ol>
				<script>
					console.log('loading voices preview');
					let voices = window.speechSynthesis.getVoices();
					if (!voices.length) {
						new Promise(resolve => {
							window.speechSynthesis.onvoiceschanged = () => {
								voices = window.speechSynthesis.getVoices();
								console.log('loaded voices');
								GenerateVoicesPreview();
								resolve();
							};
						});
					}


					async function CallTTS(message, args = {'voice_num': ''}) {
						let speech = new SpeechSynthesisUtterance(message);

						// Ensure voices are loaded
						let voices = window.speechSynthesis.getVoices();
						if (!voices.length) {
							await new Promise(resolve => {
								window.speechSynthesis.onvoiceschanged = () => {
									voices = window.speechSynthesis.getVoices();
									resolve();
								};
							});
						}

						// Default message if empty
						if (!message || message.trim() === "") {
							message = "nah, i ain't reading that... I'm sorry or congratulations";
						}
						speech.text = message;

						// Fallback values
						speech.lang = "en";
						speech.pitch = 1.1;
						speech.rate = 1.1;
						if (args.voice_num) {
							speech.voice = voices[args.voice_num];
						}
						speech.volume = 0.6;

						// Emit voice
						window.speechSynthesis.speak(speech);
					}

					console.log(`voices.length: `, voices.length);

					function GenerateVoicesPreview() {
						for (let i = 0; i < voices.length; ++i) {
							//console.log(`adding voice preview for voice: ${i}`);
							let li = d.createElement('li');
							li.style.border = '1px solid white';

							let label_for_name = d.createElement('span');
							label_for_name.innerText = 'name: ';
							li.appendChild(label_for_name);

							let label_name = d.createElement('span');
							label_name.innerText = voices[i].name;
							li.appendChild(label_name);

							let label_lang = d.createElement('span');
							label_lang.style.minWidth = '10rem';
							label_lang.style.paddingLeft = '0.2rem';
							label_lang.style.paddingRight = '0.2rem';
							label_lang.innerText = voices[i].lang;
							li.appendChild(label_lang);

							//append to list for tts options if not already added
							let added_langs = document.getElementById('tts_languages');
							let lang_added = false;
							let child;
							//see if item exists
							for (let j = 0; j < added_langs.children.length; ++j) {
								try {
									child = added_langs.children[j];
									if (child.innerHTML == label_lang.innerText) { // span tags don't have innerText for some reason
										lang_added = true;
										break;
									}
								}
								catch (err) {
									console.warn(err);
									break;
								}
							}
							//if not, add it in an alphabetical order
							if (lang_added == false) {
								console.log('lang not found, adding to list');
								let added_into_list = false;

								for (let j = 0; j < added_langs.children.length; ++j) {
									if (added_langs.children[j].innerHTML.toLowerCase() > label_lang.innerText.toLowerCase()) {
										console.log('inserted alphabetically');
										added_into_list = true;
										added_langs.insertBefore(label_lang, added_langs.children[j]);
										break;
									}
								}

								if (!added_into_list) {
									console.log('compare not found, inserting at end');
									added_langs.appendChild(label_lang);
								}
							}


							let pvb = d.createElement('button');
							pvb.type = 'button';
							pvb.innerText = `preview voice #${i}`;
							pvb.style.backgroundColor = 'darkgreen';
							pvb.addEventListener('click', (e) => {
								CallTTS(
									document.getElementById('tts_test_text').value ||
									'couldnt read preview text so heres this instead',
									{
										'voice_num': i
									}
								);
							});
							li.appendChild(pvb);

							document.getElementById('voices_preview').appendChild(li);
						}
					}
				</script>
			</details>
			<!-- {{{2 preview generator for tts voices -->
			<br>
			<impl>impl ⬇️</impl>
			<label>read who message is from?</label>
			<input type='checkbox' checked='true'>
			<br>
			<impl>impl ⬇️</impl>
			<label>read date message was received?</label>
			<input type='checkbox' checked='true'>
			<br>
			<impl>impl ⬇️</impl>
			<label>read date platform message was from?</label>
			<input type='checkbox' checked='true'>
			<br>
			<impl>impl ⬇️</impl>
			<label>read date platform message was from?</label>
			<input type='checkbox' checked='true'>
			<br>
		</details>
	</div>
	<div>
		<button id="start_auto_tts" style="background-color:blue;">start automatic tts</button>
		<button id="stop_auto_tts" style="background-color:purple;">stop automatic tts</button>
		<label> interval (in seconds):</label>
		<input id="auto_tts_interval" min="15" max="6000" default="300" type="range"><span
			id="auto_tts_interval_display"></span>
		<script>
			class IntTimer2 {
				constructor(
					args = {
						timerName: "",
						tick: 1,
						timeoutDuration: 1,
						killOnTimeout: false,
						autoStart: false
					}
				) {
					this.timerName = args.timerName;
					this.tick = args.tick;
					this.timeoutDuration = args.timeoutDuration;
					this.killOnTimeout = args.killOnTimeout;
					this.time = 0;
					this.autoStart = args.autoStart;

					this.listeners = [];

					if (this.autoStart == true) {
						this.Start();
					}
				}

				Start() {
					console.log(`IntTimer: Starting timer with interval of: ${this.timeoutDuration}`);
					this.timer = setInterval(() => {
						this.Tick();

					}, 1000);
				}

				Pause() {
					clearInterval(this.timer);
				}

				Stop() {
					this.Pause();
					this.Restart();
				}

				Restart() {
					this.time = 0;
				}

				Tick() {
					console.log(`timer ${this.timerName}: tick`);

					this.time += 1;

					if (this.time % this.timeoutDuration == 0) {
						this.Timeout();
					}
				}

				Timeout() {
					console.log(`timer ${this.timerName} Has Timeout'd`);

					this.Emit();

					if (this.killOnTimeout == true) {
						this.Kill();
					}
				}

				Kill() {
					console.log(`timer ${this.timerName} Has been killed`);
					this.killOnTimeout = true;

					this.listeners = [];

					clearInterval(this.timer);
				}

				// signal stuff
				Connect(connect_func) {
					this.listeners.push(connect_func);
				}

				Emit(data) {
					//console.log('listener amnt: ' + this.listeners.length);
					//console.log('listeners: ' + this.listeners.json());

					for (let i = 0; i < this.listeners.length; ++i) {
						this.listeners[i](data);
						//if (typeof this.listeners[i] === 'function') {
						//} else {
						//	console.error("Listener is not a function:", this.listeners[i]);
						//}
					}
				}

				Disconnect(listener) {
					this.listeners = this.listeners.filter(l => l !== listener);
				}
			}

			const Auto_TTS_Timer = new IntTimer2;
			let start_auto_tts =
				document.getElementById("start_auto_tts");
			start_auto_tts.addEventListener("click", (e) => {
				Auto_TTS_Timer.Start();
			});
			let stop_auto_tts =
				document.getElementById("stop_auto_tts");
			stop_auto_tts.addEventListener("click", (e) => {
				Auto_TTS_Timer.Stop();
			});

			let auto_tts_interval = document.getElementById("auto_tts_interval");
			console.log("auto_tts interval is: " + auto_tts_interval.value);
			let auto_tts_interval_display = document.getElementById("auto_tts_interval_display");
			auto_tts_interval.addEventListener("mousemove", (e) => {
				auto_tts_interval_display.innerHTML = auto_tts_interval.value;
			});

			Auto_TTS_Timer.Connect(() => {
				Auto_TTS_Timer.timeoutDuration = auto_tts_interval.value;
				console.log("new timeout duration for auto_tts: " + Auto_TTS_Timer.timeoutDuration);
				let messages =
					document
						.getElementById("messages_display")
						.children;

				console.log(JSON.stringify(messages));

				let new_list = [];

				for (let i = 0; i < messages.length; ++i) {
					let checkbox = messages[i].querySelector("#is_tss_message_in_queue");
					if (checkbox && checkbox.checked) {
						let messageText = messages[i].querySelector("#td_message")?.innerText || "(empty message)";
						console.log("adding message to queue! " + messageText);
						new_list.push(messages[i]);
					}
				}
				console.log("messages: " + messages + "\nnew list: " + new_list);

				messages = new_list;

				console.log(messages);

				//messages_in_queue:
				let messages_in_queue;
				if (messages.length > 0) {
					messages_in_queue = messages.length - 1
				}
				else {
					messages_in_queue = 0;
				}
				document.getElementById("tts_message_queue").innerHTML = messages_in_queue;

				//next_auto_tts:
				let count = Auto_TTS_Timer.timeoutDuration;
				let timer = setInterval(() => {
					count -= 1;
					d.getElementById('next_auto_tts').innerText = count;
					if (count == 0) {clearInterval(timer)};
				}, 1000);

				if (messages.length > 0) {
					//clear and read next message
					messages[0]
						.children
						.td_in_queue_container
						.children
						.is_tss_message_in_queue
						.checked = false;
					messages[0]
						.children
						.td_play_now
						.children
						.tr_play_now_button
						.click();
				}

			});
		</script>
	</div>
	<div style="max-height: 20em; overflow-y: scroll;">
		<impl> this does not reverse sort properly</impl>
		<table>
			<tbody id="messages_display">
				<tr>
					<th>author</th>
					<th>platform</th>
					<th>date (YMD)</th>
					<th>message</th>
					<th>play now</th>
					<th>in queue</th>
					<th>skip</th>
					<th>delete</th>
				</tr>
			</tbody>
		</table>
	</div>

	<div style="
				position:fixed; 
				bottom:0px; 
				left:0px;
				background-color:black; 
				color:white; 
				width:100%; 
				padding:0px;
				margin:0px;">
		<div style="padding:0.6em">
			<span style='padding-right:2em'>tts info: </span>
			<span style='padding-right:2em'>next update in: <span id='tts_update_time'>0</span></span>
			<span style='padding-right:2em'>messages in queue: <span id='tts_message_queue'>0</span></span>
			<span style='padding-right:2em'>total messages: <span id='tts_message_total'>0</span></span>
			<span style='padding-right:2em'>next auto tts: <span id='next_auto_tts'>0</span></span>
		</div>
		<div>
			cockatiel by vulbyte is using: Node.js <span id="node-version"></span>,
			Chromium <span id="chrome-version"></span>,
			and Electron <span id="electron-version"></span>.
		</div>
	</div>

	<!-- You can also require other files to run in this process -->
	<script src="./renderer.js"></script>
</body>

</html>
